---
title: 教程 - 了解 Azure IoT 中心的加密和 X.509 证书 | Microsoft Docs
description: 教程 - 了解 Azure IoT 中心的加密和 X.509 PKI
author: v-gpettibone
ms.service: iot-hub
services: iot-hub
ms.topic: tutorial
ms.date: 02/25/2021
ms.author: robinsh
ms.custom:
- mvc
- 'Role: Cloud Development'
- 'Role: Data Analytics'
ms.openlocfilehash: 096d7bb1ca05f3d49c0b5c93751238f41e724ec6
ms.sourcegitcommit: 0046757af1da267fc2f0e88617c633524883795f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/13/2021
ms.locfileid: "121724396"
---
# <a name="tutorial-understanding-public-key-cryptography-and-x509-public-key-infrastructure"></a>教程：了解公钥加密和 X.509 公钥基础结构

你可以使用 X.509 证书向 Azure IoT 中心证明设备的身份。 证书是包含设备公钥的数字文档，可用于验证设备所声称的身份。 X.509 证书和证书吊销列表 (CRL) 由 [RFC 5280](https://tools.ietf.org/html/rfc5280) 记录。 证书只是 X.509 公钥基础结构 (PKI) 的一部分。 若要理解 X.509 PKI，你需要理解加密算法、加密密钥、证书和证书颁发机构 (CA)：

* **算法** 定义原始明文数据如何转换为密文，以及密文如何转换回明文。
* **密钥** 是随机或伪随机的数据字符串，用作算法的输入。
* **证书** 是包含实体公钥的数字文档，可用于确定证书的使用者是否具有其所声称的身份。
* **证书颁发机构** 证明证书使用者的真实性。

你可以从证书颁发机构 (CA) 购买证书。 如果是用于测试和开发，或者你是在自包含的环境中工作，你也可以创建自签名的根 CA。 例如，如果你拥有一个或多个设备，并且正在测试 IoT 中心身份验证，则可以对根 CA 进行自签名，使用该 CA 来颁发设备证书。 你还可以颁发自签名的设备证书。 后续文章中对此进行了讨论。

在更详细地讨论 X.509 证书并使用它们向 IoT 中心证明设备身份之前，我们将讨论证书所基于的加密。

## <a name="cryptography"></a>密码

加密用于保护信息和通信。 这通常是通过以下过程完成的：使用加密技术将明文（普通文本）转换为密文（编码文本），然后再将其转换回来。 此转换过程称为加密。 反向过程称为解密。 加密涉及到以下目标：

* **机密性**：信息只有目标受众才能理解。
* **完整性**：无法在存储中或传输过程中更改信息。
* **不可否认性**：信息创建者以后不能否认该创建操作。
* **身份验证**：发送方和接收方可以确认彼此的身份。

## <a name="encryption"></a>加密

加密过程需要一种算法和一个密钥。 算法定义如何将数据从明文转换为密文，以及如何将密文转换回明文。 密钥是随机数据字符串，用作算法的输入。 该过程的所有安全性都包含在密钥中。 因此，必须安全地存储密钥。 然而，最常用的算法的详细信息是公开提供的。

有两种类型的加密。 对称加密使用同一密钥进行加密和解密。 非对称加密使用不同但数学上相关的密钥进行加密和解密。

### <a name="symmetric-encryption"></a>对称加密

对称加密使用同一密钥将明文加密为密文，以及将密文解密为明文。 密钥的必要长度（以位数表示）取决于算法。 在使用密钥来加密明文之后，加密的消息被发送给接收方，然后接收方对密文进行解密。 对称密钥必须安全地传输给接收方。 使用对称算法时，最大的安全风险是在发送密钥的过程中。

![对称加密示例](media/tutorial-x509-introduction/symmetric-keys.png)

### <a name="asymmetric-encryption"></a>非对称加密

如果只使用对称加密，存在的问题是通信各方必须拥有私钥。 但是，在你向经授权用户传输密钥的过程中，未经授权的第三方可能会捕获密钥。 若要解决此问题，请改用非对称加密或公钥加密。

在非对称加密中，每个用户都有两个数学上相关的密钥，称为密钥对。 一个密钥是公开的，另一个密钥是私密的。 密钥对确保只有接收方才能访问解密数据所需的私钥。 下图总结了非对称加密过程。

![非对称加密示例](media/tutorial-x509-introduction/asymmetric-keys.png)

1. 接收方创建一个公钥-私钥对，并将公钥发送给某个 CA。 CA 将公钥打包在 X.509 证书中。

1. 发送方从 CA 获取接收方的公钥。

1. 发送方使用某种加密算法来加密明文数据。 使用接收方的公钥执行加密。

1. 发送方将密文传输给接收方。 不需要发送密钥，因为接收方已经有解密密文所需的私钥。

1. 接收方使用指定的非对称算法和私钥来解密密文。

### <a name="combining-symmetric-and-asymmetric-encryption"></a>组合使用对称加密和非对称加密

可以将对称加密和非对称加密组合使用，以利用它们的相对优势。 对称加密比非对称加密快得多，但由于需要向其他方发送私钥，因此不那么安全。 若要将这两种类型组合使用，可以使用对称加密将明文转换为密文。 使用非对称加密来交换对称密钥。 下图对此进行了演示。

![对称加密和非对称加密](media/tutorial-x509-introduction/symmetric-asymmetric-encryption.png)

1. 发送方检索接收方的公钥。

1. 发送方生成一个对称密钥，并使用它来加密原始数据。

1. 发送方使用接收方的公钥来加密对称密钥。

1. 发送方将加密后的对称密钥和密文传输给目标接收方。

1. 接收方使用与接收方的公钥匹配的私钥来解密发送方的对称密钥。

1. 接收方使用对称密钥来解密密文。

### <a name="asymmetric-signing"></a>非对称签名

可以使用非对称算法来防止数据修改，并证明数据创建者的身份。 下图显示了非对称签名如何帮助证明发送方的身份。

![非对称签名示例](media/tutorial-x509-introduction/asymmetric-signing.png)

1. 发送方通过非对称加密算法传递明文数据，使用私钥进行加密。 请注意，此场景逆转了前面详述非对称加密的部分中概述的私钥和公钥的使用。

1. 生成的密文发送给接收方。

1. 接收方从目录中获取发起方的公钥。

1. 接收方使用发起方的公钥来解密密文。 生成的明文证明发起方的身份，因为只有发起方可以访问最初对原始文本进行加密的私钥。

## <a name="signing"></a>签名

数字签名可用于确定数据在传输过程中或静态时是否被修改。 数据通过哈希算法传递，该算法是一个单向函数，可以根据给定的消息产生数学结果。 结果称为“哈希值”、“消息摘要”、“摘要”、“签名”或“指纹”。 无法反转哈希值来获取原始消息。 因为消息中的小更改会导致指纹中的显著更改，所以可以使用哈希值来确定消息是否已更改。 下图展示了如何使用非对称加密和哈希算法来验证消息是否未被修改。

![签名示例](media/tutorial-x509-introduction/signing.png)

1. 发送方创建一条明文消息。

1. 发送方将明文消息哈希化以创建消息摘要。

1. 发送方使用私钥来加密摘要。

1. 发送方将明文消息和加密的摘要传输给目标接收方。

1. 接收方使用发送方的公钥来解密摘要。

1. 接收方运行发送方对消息使用的哈希算法。

1. 接收方将生成的签名与解密的签名进行比较。 如果两个摘要相同，则消息在传输过程中没有被修改。

## <a name="next-steps"></a>后续步骤

若要详细了解构成证书的字段，请参阅[了解 X.509 公钥证书](tutorial-x509-certificates.md)。

如果你已经详细了解 X.509 证书，想要生成可用于向 IoT 中心进行身份验证的测试版本，请参阅以下主题：

* [使用 Microsoft 提供的脚本来创建测试证书](tutorial-x509-scripts.md)
* [使用 OpenSSL 创建测试证书](tutorial-x509-openssl.md)
* [使用 OpenSSL 创建自签名测试证书](tutorial-x509-self-sign.md)

如果你有证书颁发机构 (CA) 证书或从属 CA 证书，并且想要将其上传到 IoT 中心并证明自己拥有该证书，请参阅[证明对 CA 证书的所有权](tutorial-x509-prove-possession.md)。
